def getN():
    return int(input())
def getNM():
    return map(int, input().split())
def getList():
    return list(map(int, input().split()))
def getArray(intn):
    return [int(input()) for i in range(intn)]
def input():
    return sys.stdin.readline().rstrip()

import sys
sys.setrecursionlimit(1000000000)
mod = 10 ** 9 + 7

#############
# Main Code #
#############

"""
M * Nのマスに1, 2, 3を置いていく
順に置いていこう

dpでもない
1 ~ 1間は1マス以上離れてないといけない
1マス「以上」
結局綺麗に整列してないといけないのでは
1は隣に置けないだけであって結構自由における
2と3の置き方

3 * 3なら
3の置き方は一番上、3通り
　　　　　 ２番目、2通り
 　　　　　３番目、1通り

1 * M の場合は
1つ目1, 2, 3各1
2つ目 1つ目1: 2, 3
      1つ目2: 1, 3
      1つ目3: 1, 2

3 * 3 * 3 * Mで通りを求められる
2行目以降は？

1を入れていかないと3が間に合わないところがある
1 2 3
このあと3は入らない2も入らないので
1 2 3 1
このあと1も3も入らない
1 2 3 1 2 続けると
1 2 3 1 2 1 3 1 2 1 3...

1 2 1 3...が永遠に続く
案外通りの数は少ない
1 2 1 2とは2が条件を満たさないのでできない

1 2 1 3
3 1 2 1
1 3 1 2
2 1 3 1 のキューブが出来上がるが

一つ目は[1 2 1 3], [1 3 1 2], [2 1 3 1], [3 1 2 1]のどれでもいいが

例えば左上をこうすると
　1 2 1 3 [1 2 1 3] 確定
　2 1 3 1 [2 1 3 1] [2 1 3 1]と[3 1 2 1]のどちらでもいいがその時点で下のも確定する
　1 3 1 2  1 3 1 2 確定
　3 1 2 1  3 1 2 1 確定

キューブの配置位置を考えたらあとは端数部分を計算する
キューブ内の配置は8つしかない

1 2 1 3
2 1 3 1
1 3 1 2
3 1 2 1　このキューブだった場合、横に何を置ける？

1 2 1 3   1 2
2 1 3 1   2 1
1 3 1 2   1 3
3 1 2 1   3 1
1 3   1 2 1 3
3 1   2 1 3 1
1 2   1 3 1 2
2 1   3 1 2 1

結局キューブを敷き詰めたののどこかを切り取るだけ
1行の場合
M = 1 3通り
M = 2 4通り　[1 2] [1 3] [3 1] [2 1]
M = 3
実際にキューブを切り取って見よう
"""

parts = [[1, 2, 1, 3], [1, 3, 1, 2], [2, 1, 3, 1], [3, 1, 2, 1]]
array = []
for i in range(4):
    for j in range(2):
        opt = []
        opt.append(parts[i])
        opt.append(parts[(i + j + 2) % 4])
        opt.append(parts[(i // 2) * 2 + (i % 2 == 0)])
        opt.append()
